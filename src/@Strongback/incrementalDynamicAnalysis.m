function results = incrementalDynamicAnalysis(obj,gm_mat,mu_T)
%% INCREMENTALDYNAMICANALYSIS Perform an IDA on the model
%
%   results = incrementalDynamicAnalysis(obj,gm_mat) uses the .mat file specified
%       by `gm_mat` to perform an incremental dynamic analysis. The .mat file must
%       be of the format generated by the `FEMAP695` package.
%

SMT = FEMAP695.SMT(obj.fundamentalPeriod,obj.seismicDesignCategory);
SF1 = FEMAP695.SF1(obj.fundamentalPeriod,obj.seismicDesignCategory);

temp = load(gm_mat);
ground_motions = temp.ground_motions; % necessary for parfor transparency

gm = cell(obj.optionsIDA.nMotions,1);
gm(:) = {struct};
parfor gmIndex = 1:obj.optionsIDA.nMotions
    gmID   = ground_motions(gmIndex).ID;
    gmFile = scratchFile(obj,sprintf('acc%s.acc',gmID));
    dt     = ground_motions(gmIndex).dt;
    tEnd   = ground_motions(gmIndex).time(end) + obj.optionsIDA.tExtra;
    accel  = ground_motions(gmIndex).normalized_acceleration;
    dlmwrite(gmFile,accel*obj.g);

    ST = 0;
    count = 0;
    ER = 0;
    ST_all = NaN(ceil(3/obj.optionsIDA.ST_step)*2,1);
    rh = cell(size(ST_all));
    anaCount = 1;
    while ER < 1
        ST = ST + obj.optionsIDA.ST_step;
        count = count + 1;
        ST_all(count) = ST;
        if obj.verbose
            fprintf('Running analysis %i, ST=%gg\n', anaCount, ST)
            anaCount = anaCount+1;
        end
        [ER,rh{count}] = IDApoint(obj,gmFile,dt,ST*SF1/SMT,tEnd,gmID,1);
    end
    ST_collapse = ST;
    ST_noCollapse = ST_all(end-1);
    if isnan(ST_noCollapse)
        ST_noCollapse = 0;
    end
    % Collapse! Now to bisect
    while (ST_collapse - ST_noCollapse) > obj.optionsIDA.ST_tol
        if ER > 1 %Collapse occurred, need to drop
            ST_collapse = ST;
        else %Collapse didn't occur, need to step up
            ST_noCollapse = ST;
        end
        ST = ST_noCollapse + (ST_collapse - ST_noCollapse)/2;
        count = count + 1;
        ST_all(count) = ST;
        if obj.verbose
            fprintf('Running analysis %i, ST=%gg\n', anaCount, ST)
            anaCount = anaCount+1;
        end
        [ER,rh{count}] = IDApoint(obj,gmFile,dt,ST*SF1/SMT,tEnd,gmID,1);
    end
    [ST_all,I] = sort(ST_all);
    ST_all(isnan(ST_all)) = [];
    rh = rh(I);
    rh = [rh{:}];

    temp = [rh.energy];
    gm{gmIndex}.ID = gmID;
    gm{gmIndex}.maxDriftRatio = [rh.maxDriftRatio];
    gm{gmIndex}.collapseIndex = find(~isnan([temp.collapseIndex]),1);
    gm{gmIndex}.ST = ST_all';
    gm{gmIndex}.SCT = ST_all(gm{gmIndex}.collapseIndex);
    gm{gmIndex}.rh = rh;
    % gm{gmIndex}.solvetime = solvetime;
    % gm{gmIndex}.calctime  = calctime;

    if obj.deleteFilesAfterAnalysis
        delete(gmFile)
    end
end
gm = [gm{:}];
SCT_hat = median([gm.SCT]);
CMR = SCT_hat/SMT;
SSF = FEMAP695.SSF(obj.fundamentalPeriod,mu_T,obj.seismicDesignCategory);
ACMR = SSF*CMR;
beta_total = FEMAP695.beta_total(obj.optionsIDA.rating_DR,obj.optionsIDA.rating_TD,obj.optionsIDA.rating_MDL,mu_T);
ACMR20 = FEMAP695.ACMRxx(beta_total,0.2);

results = struct;
results.ACMR    = ACMR;
results.ACMR20  = ACMR20;
results.SMT     = SMT;
results.SCT_hat = SCT_hat;
results.SSF     = SSF;
results.beta_t  = beta_total;
results.gm      = gm;

end

function [energyRatio,results] = IDApoint(obj,gmFile,dt,SF,tEnd,gmID,index)
% IDAPOINT Perform a response history and return the maximum gravity to earthquake energy ratio.
%
%   This function is only used by INCREMENTALDYNAMICANALYSIS, but must be
%       separate for parallelization reasons.
%
results = responseHistory(obj,gmFile,dt,SF,tEnd,gmID,index);
results.energy = energyCriterion(obj,results);
results.maxDriftRatio = max(max(abs(results.storyDrift))./obj.storyHeight);
energyRatio = max(results.energy.norm_gravity ./ (results.energy.earthquake + eps)); % add eps to earthquake to avoid 0/0

end
